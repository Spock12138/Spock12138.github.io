<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Spock12138.github.io</id>
    <title>安半愚的小窝</title>
    <updated>2021-07-01T03:47:24.470Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Spock12138.github.io"/>
    <link rel="self" href="https://Spock12138.github.io/atom.xml"/>
    <subtitle>不积跬步无以至千里</subtitle>
    <logo>https://Spock12138.github.io/images/avatar.png</logo>
    <icon>https://Spock12138.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 安半愚的小窝</rights>
    <entry>
        <title type="html"><![CDATA[动态规划学习笔记]]></title>
        <id>https://Spock12138.github.io/post/dong-tai-gui-hua-xue-xi-bi-ji/</id>
        <link href="https://Spock12138.github.io/post/dong-tai-gui-hua-xue-xi-bi-ji/">
        </link>
        <updated>2021-06-27T13:31:20.000Z</updated>
        <content type="html"><![CDATA[<p><strong>估计是个比较大的工程，<s>先鸽了</s></strong><br>
<strong>一.n阶台阶问题</strong><br>
<a href="https://www.luogu.com.cn/problem/P1192">题目在这里</a><br>
如果k的取值是2，那么就是简单的斐波那契数列。<br>
按照斐波那契的思想，可以推出当k=3时，f(4)=f(1)+f(2)+f(3)。大致，从一开始递推，f(n)是多个方法的和。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>t</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo></mrow></munderover><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_i=\sum_{t=1}^{t=min(i,k)}f_{i-t}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2281180000000003em;vertical-align:-1.267113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9610050000000003em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.386005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<pre><code class="language-c++">void solve()
{
    cin&gt;&gt;n&gt;&gt;k;
    f[0]=1;
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=min(i,k);++j){
            f[i]=(f[i]+f[i-j])%10003;//数太大，取余。
        }
    }
}
</code></pre>
<p><strong>二.最大子序列和</strong><br>
<a href="https://www.luogu.com.cn/problem/P1115">题目在这里</a><br>
递推式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>n</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>n</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">f_i=max(f_{i-1}+n_i,n_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-c++">void solve()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i)
    cin&gt;&gt;arr[i];
    for(int i=1;i&lt;=n;++i)
    f[i]=max(f[i-1]+arr[i],arr[i]);//最后记得取数组最大值
}
</code></pre>
<p><strong>三.背包问题</strong></p>
<ol>
<li><strong>01背包</strong><br>
<s>板子使我快乐</s><br>
递推公式，其他背包变形都是在此推导出来的。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>j</mi></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>f</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>j</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub></mrow></msub><mo>+</mo><msub><mi>v</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">f_j=max(f_j,f_{j-w_i}+v_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.02691em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ol>
<pre><code class="language-c++">void solve()
{
    for(int i=1;i&lt;=n;++i){
        for(int j=W;j&gt;=w[i];--j)
        f[j]=max(f[j],f[j-w[i]]+v[i]);
    }
}
</code></pre>
<p>2.<strong>完全背包</strong><br>
一件物品可以放任意多次</p>
<pre><code class="language-c++"></code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dijkstra+堆优化]]></title>
        <id>https://Spock12138.github.io/post/dijkstradui-you-hua/</id>
        <link href="https://Spock12138.github.io/post/dijkstradui-you-hua/">
        </link>
        <updated>2021-06-26T08:38:15.000Z</updated>
        <content type="html"><![CDATA[<p>之前咕了好久，在尝试<a href="https://www.luogu.com.cn/problem/P1339">这题</a>的时候跟着大佬学习了堆优化(<s>虽然说不加优化也能过</s>)。<br>
<strong>先说下思想</strong>，Dij的核心就是贪心松弛，在寻找最近的点使用<code>for(i 1:n)</code>，时间复杂度是O(n)。而使用堆优化可以将复杂度降到O(logn)。<br>
利用堆实现优先队列的功能。</p>
<p><strong>代码</strong></p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const long long inf =21474836;
const int maxn=10005;
const int maxm=500005;
int n,m,s,t,edge_num;
int dis[maxn],head[maxn];
struct Edge
{
    int nxt,to,dis;
}edge[maxm];
/**
下面的node节点的建立是关键。重构运算符，实现了堆操作。
其实priority_queue也算个堆。
**/
struct node
{
    int u,v;//这里的u表示点，v表示点到目标点的距离
    bool operator &lt;(const node &amp;b)const{
        return u&gt;b.u;//实现距离近的点排在前列
    }
}
/**
struct node 
{
    int u,v;
    bool operator &lt;(const node &amp;a,const node &amp;b){
        return a.u&gt;b.u;
    }
}
**/

void add_edge(int u,int v,int w)
{
      edge[edge_num].nxt=head[u];
      edge[edge_num].to=v;
      edge[edge_num].dis=w;
      head[u]=edge_num;
}
void Dijkstra()
{
    priority_queue&lt;node&gt;q;
    for(int i=1;i&lt;=n;++i)
    dis[i]=inf;
    dis[s]=0;
    node p;
    p.v=s;
    p.u=dis[s];
    while(q.size())
    {
        int u=q.top().v;
        int d=q.top().u;
        if(d!=dis[u])
        continue;
        for(int i=head[u];i;i=edge[i].nxt){
            int v=edge[i].to;
            if(dis[v]&gt;dis[u]+edge[i].dis){
                dis[v]=dis[u]+edge[i].dis;
                node p;
                p.v=v,p.u=dis[v];
                q.push(p); 
            }
        }
    }
}
void solve()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;//读入优化就不敲了
    for(int i=1;i&lt;=m;++i){
        int u,v,w;
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        add_edge(u,v,w);
        add_edge(v,u,w);//注意是双向边
    }
    Dijkstra();
    cout&lt;&lt;dis[t]&lt;&lt;endl;
}
int main()
{
    solve()
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[卡特兰数三种推导]]></title>
        <id>https://Spock12138.github.io/post/qia-te-lan-shu-si-chong-tui-dao/</id>
        <link href="https://Spock12138.github.io/post/qia-te-lan-shu-si-chong-tui-dao/">
        </link>
        <updated>2021-06-20T13:19:53.000Z</updated>
        <content type="html"><![CDATA[<p>在做栈相关的的问题，遇到了卡特兰数的问题。了解了不同的求解方法<br>
<strong>第一种，记忆化搜索</strong></p>
<pre><code>int dfs(i,j)
{
    if(f[i][j])
    return f[i][j];
    if(i==0)
    return 1;
    if(j&gt;0)f[i][j]+=dfs(i,j-1);
    f[i][j]+=dfs(i-1,j+1);
    return f[i][j];
}
void solve()
{
    dfs(n,0);
}
</code></pre>
<p><strong>第二种，递推，dp</strong></p>
<pre><code>void solve()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=n;++j){
            if(i==j)f[i][j]=f[i-1][j];//初始化，栈中元素为空，必须队列出一个元素填入
            else f[i][j]=f[i-1][j]+f[i][j-1];
        }
    }
}
</code></pre>
<p><strong>第三种，卡特兰数</strong><br>
第三种学到了好多，比如排列数的递推，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo><mo>=</mo><mi>C</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>C</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">C(n,m)=C(n-1,m-1)+C(n-1,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，可以不使用又臭又长的阶乘。<br>
设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>为第n个卡特兰数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>C</mi><mo>(</mo><mn>2</mn><mo>∗</mo><mi>n</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mo>−</mo><mi>C</mi><mo>(</mo><mn>2</mn><mo>∗</mo><mi>n</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">=C(2*n,n)-C(2*n,n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<pre><code>void solve()
{
    for(int i=1;i&lt;=2*n;++i){
        f[i][i]=f[i][0]=1;//f[][]为组合数，递推组合数
        for(int j=1;j&lt;i;++j){
            f[i][j]=f[i-1][j-1]+f[i-1][j];
        }
    }
    cout&lt;&lt;f[2*n][n]-f[2*n][n-1];
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[复习约瑟夫环]]></title>
        <id>https://Spock12138.github.io/post/fu-xi-yue-se-fu-huan/</id>
        <link href="https://Spock12138.github.io/post/fu-xi-yue-se-fu-huan/">
        </link>
        <updated>2021-06-16T00:48:53.000Z</updated>
        <content type="html"><![CDATA[<p>约瑟夫环总结，利用一天的时间回顾了约瑟夫的几种算法。顺便学习了利用指针，构建一个双向链表，存储队列。<br>
这里总结一下最简单的求约瑟夫环顺序的方法--模拟队列法：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;queue&gt;
using namespace std;
queue&lt;int&gt;q;
int n,m,nownum;//n：总人数，m：数到m出队
void solve()
{
     cin&gt;&gt;n;
     for(int i=1;i&lt;=n;++i)
     q.push(i);
     newnum=1;
     while(n){//直到所有人都出队
             if(nownum==m){
                 cout&lt;&lt;q.front()&lt;&lt;&quot; &quot;;
                 q.pop();
                 nownum=1;
                 --n;
             }
             else{
                 ++nownum;
                 q.push(q.front());
                 q.pop();
             }
     } 
}
</code></pre>
<p>这里补充下双向链表</p>
<pre><code>const int n=10005;
struct Peo{
    int ID;
    Peo *next,*front;
    Peo(){
        next=front=0;
    }
}p[n];
void solve()//建立链表
{
     for(int i=1;i&lt;n-1;++i) //这里排除队首，队尾
     {
          p[i].front=p+i-1;
          //**这里笔者敲错了。
          点（.）是用于结构体变量访问成员，箭头（-&gt;）是用于结构体指针访问成员。
          **/
          p[i].next=p+i+1;
          p[i].id=i+1;   
     }
     p[0].front=p+n-1;
     p[n-1].front=p+n-2;
     p[0].next=p+1;
     p[n-1].next=p;
     p[0].ID=1;
     p[n-1].ID=n;
}
void cut(Peo *num)
{
    num=num-&gt;front;
    num-&gt;next=num-&gt;next-&gt;next;//注意，p-&gt;next等价于q。
    num=num-&gt;next;
    num-&gt;front=num-&gt;front-&gt;front;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[转载--人生的真谛]]></title>
        <id>https://Spock12138.github.io/post/zhuan-zai-ren-sheng-de-zhen-di/</id>
        <link href="https://Spock12138.github.io/post/zhuan-zai-ren-sheng-de-zhen-di/">
        </link>
        <updated>2021-06-16T00:46:05.000Z</updated>
        <content type="html"><![CDATA[<p>如果</p>
<p>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</p>
<p>分别等于</p>
<p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26。</p>
<p>那么：</p>
<p>Knowledge (知识)： K+N+O+W+L+E+D+G+E＝ 11+14+15+23+12+5+4+7+5=96。</p>
<p>Workhard (努力工作）：W+O+R+K+H+A+R+D＝ 23+15+18+11+8+1+18+4 =98。</p>
<p>也就是说知识和努力工作对我们人生的影响可以达到96和98。</p>
<p>Luck（好运） L+U+C+K＝12+21+3+11=47。</p>
<p>Love（爱情） L+O+V+E＝12+15+22+5=54。</p>
<p>看来，这些我们通常认为重要的东西却并没起到最重要的作用。</p>
<p>那么，什么可以决定我们100的人生呢？</p>
<p>是Money（金钱）吗？M+O+N+E+Y=13+15+14+5+25=72。</p>
<p>看来也不是。</p>
<p>是Leadership (领导能力)吗？</p>
<p>L+E+A+D+E+R+S+H+I+P=12+5+1+4+5+18+19+9+16=89。</p>
<p>还不是。</p>
<p>金钱，权力也不能完全决定我们的生活。那是什么呢？</p>
<p>其实，真正能使我们生活圆满的东西就在我们的代码里面！</p>
<p>iostream(输入输出流所在的头文件)=9+15+19+20+18+5+1+13=100。<br>
<s>so,骚年，努力敲代码吧</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[匹配子序列两个模板]]></title>
        <id>https://Spock12138.github.io/post/pi-pei-zi-xu-lie-liang-ge-mo-ban/</id>
        <link href="https://Spock12138.github.io/post/pi-pei-zi-xu-lie-liang-ge-mo-ban/">
        </link>
        <updated>2021-06-13T13:28:37.000Z</updated>
        <content type="html"><![CDATA[<p>今天第一次遇到子序列的问题，<s>自己写的太难看了</s>，就记了几个板子。</p>
<pre><code class="language-c++">void solve1()//删除法，删去匹配成功的，flag判断是否有不合格的
{
    while(cin&gt;&gt;s&gt;&gt;t){
        int flag=0;
        for(int i=0;s[i];++i){
            int mark=t.find(s[i]);
            if(mark!=-1){
                t.erase(0,mark+1);//删去不必要的，优化
            }
            else {
                flag=1;
                cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;
                break;
            }
        }
        if(!flag) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;
    }
}
</code></pre>
<p>第二种方法  //写的太漂亮了</p>
<pre><code class="language-c++">void solve2()
{
    while(cin&gt;&gt;s&gt;&gt;t){
        queue&lt;char&gt;qs;
        for(const char &amp;e:s)
        qs.push(e);
        for(const char &amp;e:t)
        if(e==qs.front())
        qs.pop();
        cout&lt;&lt;(qs.empty()?&quot;Yes&quot;:&quot;No&quot;)&lt;&lt;endl;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图论学习总结--Floyd，spfa与dijkstra模板]]></title>
        <id>https://Spock12138.github.io/post/tu-lun-xue-xi-zong-jie/</id>
        <link href="https://Spock12138.github.io/post/tu-lun-xue-xi-zong-jie/">
        </link>
        <updated>2021-06-09T14:35:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一图的存储">一.图的存储</h3>
<p>首先学习了三种图的存储方式。<br>
1.直接结构题存储边的信息。<br>
2.利用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">vector</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 数组，实现邻接矩阵存储图的信息。代码如下</p>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
vector&lt;bool&gt; vis;
vector&lt;vector&lt;bool&gt; &gt;adj;//这里可以改成int，设置边权
int n,m;
bool find_edge(int u,int v){
    return adj[u][v];
}
void dfs(int u){
    if(vis[u])
    return ;
    vis[u]=1;
    for(int v=1;v&lt;=n;++v){
        if(adj[u][v]){
            dfs(v);
        }
    }
}
int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    vis.resize(n+1,false);
    adj.resize(n+1,vector&lt;bool&gt;(n+1,false));//易忘
    for(int i=1;i&lt;=m;++i){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        adj[u][v]=1;
    }
    return 0;
}
</code></pre>
<p>3.链式前向星存图 , 此处有 <a href="https://oi-wiki.org/graph/save/"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>i</mi><mi>w</mi><mi>i</mi><mi>k</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">oi wiki</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">i</span></span></span></span> 链接</a>，使用vector实现，思想大同小异。</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int maxn=10005;
const int maxm=500005;
const int inf=2147483647;
struct Edge{
    int dis,to,nxt;
}edge[maxm];
int n,m,s,edge_num;
int dis[maxn],head[maxm];
bool vis[maxn];
void add_edge(int u,int v,int w)
{
      edge[++edge_num].nxt=head[u];
      edge[edge_num].to=v;
      edge[edge_num].dis=w;
      head[u]=edge_num;
}
int main()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
    for(int i=1;i&lt;=n;++i){
        int u,v,w;
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        add_edge(u,v,w);
    }
    return 0;
}
</code></pre>
<h3 id="二三种最短路方法">二.三种最短路方法</h3>
<p>1.Floyd算法，时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span> ( <s>其实就是三个for循环</s> )</p>
<pre><code>for(int k=1;k&lt;=n;++k){
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=n;++j){
            if(i==j||adj[i][k]==inf)
            continue;
            adj[i][j]=min(adj[i][j],adj[i][k]+adj[k][j]);
        }
    }
}
</code></pre>
<p>2.spfa算法，利用松弛操作</p>
<pre><code>void spfa()
{
    queue&lt;int&gt;q;
    for(int i=1;i&lt;=n;++i)//初始化
    {
        dis[i]=inf;
        vis[i]=0;
    }
    q.push_back(s);
    vis[s]=1;
    while(!q.empty()){
        int u=q.front();
        vis[u]=0;
        q.pop();
        for(int i=head[u];i;i=edge[i].nxt){
            int v=edge[i].to;
            if(dis[v]&gt;dis[u]+edge[i].dis){//松弛操作
                dis[v]=dis[u]+edge[i].dis;
                if(vis[v]==0){//入队操作
                    q.push(v);
                    vis[v]=1;
                }
            }
        }
    }
}
</code></pre>
<p>3.dijkstra算法，思想：贪心。优化：减少松弛。缺点：遇到负权图卡死。</p>
<pre><code>void dijkstra()
{
    for(int i=1;i&lt;=n;++i){
        dis[i]=inf;
        vis[i]=0;
    }
    int u=s;
    dis[s]=0;
    while(!vis[u]){//搜完整张图
        vis[u]=1;//标记为经过点
     for(int i=head[u];i;edge[i].nxt){
         int v=edge[i].to;
         if(dis[v]&gt;dis[i]+edge[u].dis){
             dis[v]=dis[i]+edge[u].dis;
         }
         long long minn=inf;
         for(int i=1;i&lt;=n;++i){
             if(dis[i]&lt;minn&amp;&amp;!vis[i]){
                 minn=dis[i]
                 u=i;
             }
         }
     }   
    }
}
</code></pre>
<p>以上是整理的三个最短路常见模板。关于图论的学习暂时就到这里。dijkstra的堆优化可能以后有空补上。(<s>其实就是懒得搞</s>)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法周结--搜索，排序，链式前向星建图]]></title>
        <id>https://Spock12138.github.io/post/liu-yue-di-yi-zhou-xue-xi-zong-jie/</id>
        <link href="https://Spock12138.github.io/post/liu-yue-di-yi-zhou-xue-xi-zong-jie/">
        </link>
        <updated>2021-06-06T14:26:34.000Z</updated>
        <content type="html"><![CDATA[<p>正式打算参加算法比赛，打算今年九月份报名ccf。为此现在开始刷算法，数据结构。</p>
<p>这周复习了归并排序，快速排序，快读(一次没用对过)，还有dfs，bfs。背板子使我快乐(bushi)。</p>
<pre><code>/**bfs板子，解决了cf920A。比dfs复杂些。要求使用队列。对此专门搜索了dfs与bfs的差异。dfs每层
*拓展完之后加入新的节点，如同队列，先进先出。dfs走到哪里，搜到哪里。
个人理解，bfs如同多维时间跨度同时发生。
dfs相对的是拥有回溯功能，能够回溯时间。
**/
        #include&lt;iostream&gt;
        #include&lt;cstring&gt;
        #include&lt;cstdio&gt;
        #include&lt;queue&gt;
        using namespace std;
        const int maxn=220;
        struct Node{
        int s,seq;
        }node;
        queue&lt;Node&gt;q;
        int n,len,k,t,ans=-1;
        bool vis[220];
        int main()
        {
            cin&gt;&gt;n;
            while(n&gt;0){
                --n;
                memset(vis,0,sizeof(vis));
                cin&gt;&gt;len&gt;&gt;k;
                for(int i=1;i&lt;=k;++i){
                    cin&gt;&gt;t;
                    Node tmp;
                    tmp.s=t;
                    tmp.seq=1;
                    vis[t]=1;
                    q.push(tmp);
                }
                while(!q.empty()){
                    Node x;
                    x=q.front();
                    q.pop();
                    ans=max(ans,x.seq);//cout&lt;&lt;&quot;ans:&quot;&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;endl;
                    if(x.s&gt;1&amp;&amp;!vis[x.s-1]){
                        Node tmp;
                        tmp.s=x.s-1;
                        tmp.seq=x.seq+1;
                        vis[x.s-1]=1;
                        q.push(tmp);
                    }
                    if(x.s&lt;len&amp;&amp;!vis[x.s+1]){
                        Node tmp;
                        tmp.s=x.s+1;
                        tmp.seq=x.seq+1;
                        vis[x.s+1]=1;
                        q.push(tmp);
                    }
                }
                cout&lt;&lt;ans&lt;&lt;endl;
                ans=-1;
            }
            return 0;
        }
</code></pre>
<p>下面的是合并排序，可以解决逆序对问题</p>
<pre><code>/**主要思路总结。利用b[i]记录数组a[]的分段排序。三个while实现b[]的个数到达r-l。
然后将其赋值给a[]。
**/
        void msort(int l,int r)
        {
            if(l==r)
                return ;
            int mid=(l+r)/2;
            int i=l,j=mid+1,num=l;
            msort(l,mid);
            msort(mid+1,r);
            while(i&lt;=mid&amp;&amp;j&lt;=r){
                if(a[i]&lt;=a[j]){
                    b[num]=a[i];
                    ++i,++num;
                }
                else {
                    b[num]=a[j];
                    ++j,++num;
                    ans+=mid-i+1;
                }
            }
            while(i&lt;=mid){
                b[num]=a[i];
                ++num,++i;
            }
            while(j&lt;=r){
                b[num]=a[j];
                ++num,++j;
            }
            for(int i=l;i&lt;=r;++i){
                a[i]=b[i];
            }
        }
</code></pre>
<p>最后是链表实现数组，这个当初没有进行实例化操作，很抽象。如果带入一组数据，很容易发现每个vector的作用</p>
<pre><code>      #include&lt;iostream&gt;
      #include&lt;vector&gt;
      using namespace std;
      vector&lt;int &gt; head,nxt,to;
      int u,v,n,m;
      void add_line(int u,int v)
      {
          nxt.push_back(head[u]);//nxt记录head的浏览记录，时间回溯。
          head[u]=to.size();//head记录最终位置
          to.push_back(v);//to比较容易理解。边的结束位置
      }
      bool find_edge(int u,int v)
      {
          for(int i=head[u];~i;i=nxt[i]){
            if(to[i]==v){
                return true;
            }
          }
          return false;
      }
      int main()
      {
          cin&gt;&gt;n&gt;&gt;m;
          head.resize(n+1,-1);
          nxt.resize(n+1,false);
          for(int i=1;i&lt;=m;++i){
            cin&gt;&gt;u&gt;&gt;v;
            add_line(u,v);
          }
          return 0;
      }

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法学习记录--快读，快速输出]]></title>
        <id>https://Spock12138.github.io/post/suan-fa-xue-xi-ji-lu-kuai-du-kuai-su-shu-chu/</id>
        <link href="https://Spock12138.github.io/post/suan-fa-xue-xi-ji-lu-kuai-du-kuai-su-shu-chu/">
        </link>
        <updated>2021-06-01T13:46:52.000Z</updated>
        <content type="html"><![CDATA[<p>对于数据量不大的题目，我们可以直接采用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">cin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cout</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span> 输入输出。当数据量相对大的时候，可以插入  ios::sync_with_stdio(false) 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">.</mi><mi>t</mi><mi>i</mi><mi>e</mi><mo>(</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">cin.tie(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord">.</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 关闭同步流。这时cin读入速度已经超过scanf了。<br>
但是遇到数据输入特别特别大(毒瘤)的情况下，以上方法均不适用。可以尝试使用快读</p>
<pre><code class="language-c++">inline int read()
{
    int c=0,f=1;
    char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){
        if(ch=='-')
        f*=-1;
        ch=getchar();
    }
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){
        c=c*10+ch-'0';//(c&lt;&lt;3)+(c&lt;&lt;1)
        ch=getchar();
    }
    return c*f;
}

</code></pre>
<p>快速输出(然而还没有printf()快)</p>
<pre><code class="language-c++">char f[200];
inline void write(int x)
{
   int tmp=x&gt;0?x:-x;
   if(x&lt;0)
   putchar('-');
   int cnt=0;
   while(tmp&gt;0){
       f[++cnt]=tmp%10+'0';
       tmp/=10;
   }
   while(cnt&gt;0){
       putchar(f[cnt]);
       --cnt;
   }
   return ;
}
</code></pre>
<p>递归模式的</p>
<pre><code class="language-c++">inline void write(int x)
{
    if(x&lt;0){
        putchar('-');
        x*=-1;
    }
    if(x&gt;9)
    write(x/10);
    putchar(x%10+'0');
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[会做字幕就可以为所欲为]]></title>
        <id>https://Spock12138.github.io/post/hui-zuo-zi-mu-jiu-ke-yi-wei-suo-yu-wei/</id>
        <link href="https://Spock12138.github.io/post/hui-zuo-zi-mu-jiu-ke-yi-wei-suo-yu-wei/">
        </link>
        <updated>2021-05-27T14:19:18.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p><strong>之前在摸鱼的时候，经常看到各种大神花式捕鲸。其中会做字幕的大佬带给了我特别多的欢乐，于是萌生了学习做字幕的想法。</strong></p>
<p>#所需要的工具<br>
aegisub--可以在网上直接下载，作用编辑字幕。<a href="https://www.bilibili.com/video/av6527949/">教程链接</a><br>
小丸子工具箱--用于格式转化。<a href="https://www.bilibili.com/video/av88335927/">下载链接</a></p>
<p>如果需要gif转化，gif剪切等操作，可以点<a href="https://ezgif.com/">这里</a></p>
<figure data-type="image" tabindex="1"><img src="https://Spock12138.github.io/post-images/1622125980466.gif" alt="" loading="lazy"></figure>
<p>更新，有个网站直接有模板，可以直接套用模板GIF，写出自己想要的台词。网站在<a href="https://sorry.xuty.tk/hataraku/">这里</a></p>
<figure data-type="image" tabindex="2"><img src="https://Spock12138.github.io/post-images/1622556335778.gif" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>