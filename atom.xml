<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Spock12138.github.io</id>
    <title>安半愚的小窝</title>
    <updated>2021-06-13T13:26:01.411Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Spock12138.github.io"/>
    <link rel="self" href="https://Spock12138.github.io/atom.xml"/>
    <subtitle>不积跬步无以至千里</subtitle>
    <logo>https://Spock12138.github.io/images/avatar.png</logo>
    <icon>https://Spock12138.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 安半愚的小窝</rights>
    <entry>
        <title type="html"><![CDATA[图论学习总结--Floyd，spfa与dijkstra模板]]></title>
        <id>https://Spock12138.github.io/post/tu-lun-xue-xi-zong-jie/</id>
        <link href="https://Spock12138.github.io/post/tu-lun-xue-xi-zong-jie/">
        </link>
        <updated>2021-06-09T14:35:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一图的存储">一.图的存储</h3>
<p>首先学习了三种图的存储方式。<br>
1.直接结构题存储边的信息。<br>
2.利用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">vector</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 数组，实现邻接矩阵存储图的信息。代码如下</p>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
vector&lt;bool&gt; vis;
vector&lt;vector&lt;bool&gt; &gt;adj;//这里可以改成int，设置边权
int n,m;
bool find_edge(int u,int v){
    return adj[u][v];
}
void dfs(int u){
    if(vis[u])
    return ;
    vis[u]=1;
    for(int v=1;v&lt;=n;++v){
        if(adj[u][v]){
            dfs(v);
        }
    }
}
int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    vis.resize(n+1,false);
    adj.resize(n+1,vector&lt;bool&gt;(n+1,false));//易忘
    for(int i=1;i&lt;=m;++i){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        adj[u][v]=1;
    }
    return 0;
}
</code></pre>
<p>3.链式前向星存图 , 此处有 <a href="https://oi-wiki.org/graph/save/"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>i</mi><mi>w</mi><mi>i</mi><mi>k</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">oi wiki</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">i</span></span></span></span> 链接</a>，使用vector实现，思想大同小异。</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
const int maxn=10005;
const int maxm=500005;
const int inf=2147483647;
struct Edge{
    int dis,to,nxt;
}edge[maxm];
int n,m,s,edge_num;
int dis[maxn],head[maxm];
bool vis[maxn];
void add_edge(int u,int v,int w)
{
      edge[++edge_num].nxt=head[u];
      edge[edge_num].to=v;
      edge[edge_num].dis=w;
      head[u]=edge_num;
}
int main()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
    for(int i=1;i&lt;=n;++i){
        int u,v,w;
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        add_edge(u,v,w);
    }
    return 0;
}
</code></pre>
<h3 id="二三种最短路方法">二.三种最短路方法</h3>
<p>1.Floyd算法，时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span> ( <s>其实就是三个for循环</s> )</p>
<pre><code>for(int k=1;k&lt;=n;++k){
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=n;++j){
            if(i==j||adj[i][k]==inf)
            continue;
            adj[i][j]=min(adj[i][j],adj[i][k]+adj[k][j]);
        }
    }
}
</code></pre>
<p>2.spfa算法，利用松弛操作</p>
<pre><code>void spfa()
{
    queue&lt;int&gt;q;
    for(int i=1;i&lt;=n;++i)//初始化
    {
        dis[i]=inf;
        vis[i]=0;
    }
    q.push_back(s);
    vis[s]=1;
    while(!q.empty()){
        int u=q.front();
        vis[u]=0;
        q.pop();
        for(int i=head[u];i;i=edge[i].nxt){
            int v=edge[i].to;
            if(dis[v]&gt;dis[u]+edge[i].dis){//松弛操作
                dis[v]=dis[u]+edge[i].dis;
                if(vis[v]==0){//入队操作
                    q.push(v);
                    vis[v]=1;
                }
            }
        }
    }
}
</code></pre>
<p>3.dijkstra算法，思想：贪心。优化：减少松弛。缺点：遇到负权图卡死。</p>
<pre><code>void dijkstra()
{
    for(int i=1;i&lt;=n;++i){
        dis[i]=inf;
        vis[i]=0;
    }
    int u=s;
    dis[s]=0;
    while(!vis[u]){//搜完整张图
        vis[u]=1;//标记为经过点
     for(int i=head[u];i;edge[i].nxt){
         int v=edge[i].to;
         if(dis[v]&gt;dis[i]+edge[u].dis){
             dis[v]=dis[i]+edge[u].dis;
         }
         long long minn=inf;
         for(int i=1;i&lt;=n;++i){
             if(dis[i]&lt;minn&amp;&amp;!vis[i]){
                 minn=dis[i]
                 u=i;
             }
         }
     }   
    }
}
</code></pre>
<p>以上是整理的三个最短路常见模板。关于图论的学习暂时就到这里。dijkstra的堆优化可能以后有空补上。(<s>其实就是懒得搞</s>)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法周结--搜索，排序，链式前向星建图]]></title>
        <id>https://Spock12138.github.io/post/liu-yue-di-yi-zhou-xue-xi-zong-jie/</id>
        <link href="https://Spock12138.github.io/post/liu-yue-di-yi-zhou-xue-xi-zong-jie/">
        </link>
        <updated>2021-06-06T14:26:34.000Z</updated>
        <content type="html"><![CDATA[<p>正式打算参加算法比赛，打算今年九月份报名ccf。为此现在开始刷算法，数据结构。</p>
<p>这周复习了归并排序，快速排序，快读(一次没用对过)，还有dfs，bfs。背板子使我快乐(bushi)。</p>
<pre><code>/**bfs板子，解决了cf920A。比dfs复杂些。要求使用队列。对此专门搜索了dfs与bfs的差异。dfs每层
*拓展完之后加入新的节点，如同队列，先进先出。dfs走到哪里，搜到哪里。
个人理解，bfs如同多维时间跨度同时发生。
dfs相对的是拥有回溯功能，能够回溯时间。
**/
        #include&lt;iostream&gt;
        #include&lt;cstring&gt;
        #include&lt;cstdio&gt;
        #include&lt;queue&gt;
        using namespace std;
        const int maxn=220;
        struct Node{
        int s,seq;
        }node;
        queue&lt;Node&gt;q;
        int n,len,k,t,ans=-1;
        bool vis[220];
        int main()
        {
            cin&gt;&gt;n;
            while(n&gt;0){
                --n;
                memset(vis,0,sizeof(vis));
                cin&gt;&gt;len&gt;&gt;k;
                for(int i=1;i&lt;=k;++i){
                    cin&gt;&gt;t;
                    Node tmp;
                    tmp.s=t;
                    tmp.seq=1;
                    vis[t]=1;
                    q.push(tmp);
                }
                while(!q.empty()){
                    Node x;
                    x=q.front();
                    q.pop();
                    ans=max(ans,x.seq);//cout&lt;&lt;&quot;ans:&quot;&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;endl;
                    if(x.s&gt;1&amp;&amp;!vis[x.s-1]){
                        Node tmp;
                        tmp.s=x.s-1;
                        tmp.seq=x.seq+1;
                        vis[x.s-1]=1;
                        q.push(tmp);
                    }
                    if(x.s&lt;len&amp;&amp;!vis[x.s+1]){
                        Node tmp;
                        tmp.s=x.s+1;
                        tmp.seq=x.seq+1;
                        vis[x.s+1]=1;
                        q.push(tmp);
                    }
                }
                cout&lt;&lt;ans&lt;&lt;endl;
                ans=-1;
            }
            return 0;
        }
</code></pre>
<p>下面的是合并排序，可以解决逆序对问题</p>
<pre><code>/**主要思路总结。利用b[i]记录数组a[]的分段排序。三个while实现b[]的个数到达r-l。
然后将其赋值给a[]。
**/
        void msort(int l,int r)
        {
            if(l==r)
                return ;
            int mid=(l+r)/2;
            int i=l,j=mid+1,num=l;
            msort(l,mid);
            msort(mid+1,r);
            while(i&lt;=mid&amp;&amp;j&lt;=r){
                if(a[i]&lt;=a[j]){
                    b[num]=a[i];
                    ++i,++num;
                }
                else {
                    b[num]=a[j];
                    ++j,++num;
                    ans+=mid-i+1;
                }
            }
            while(i&lt;=mid){
                b[num]=a[i];
                ++num,++i;
            }
            while(j&lt;=r){
                b[num]=a[j];
                ++num,++j;
            }
            for(int i=l;i&lt;=r;++i){
                a[i]=b[i];
            }
        }
</code></pre>
<p>最后是链表实现数组，这个当初没有进行实例化操作，很抽象。如果带入一组数据，很容易发现每个vector的作用</p>
<pre><code>      #include&lt;iostream&gt;
      #include&lt;vector&gt;
      using namespace std;
      vector&lt;int &gt; head,nxt,to;
      int u,v,n,m;
      void add_line(int u,int v)
      {
          nxt.push_back(head[u]);//nxt记录head的浏览记录，时间回溯。
          head[u]=to.size();//head记录最终位置
          to.push_back(v);//to比较容易理解。边的结束位置
      }
      bool find_edge(int u,int v)
      {
          for(int i=head[u];~i;i=nxt[i]){
            if(to[i]==v){
                return true;
            }
          }
          return false;
      }
      int main()
      {
          cin&gt;&gt;n&gt;&gt;m;
          head.resize(n+1,-1);
          nxt.resize(n+1,false);
          for(int i=1;i&lt;=m;++i){
            cin&gt;&gt;u&gt;&gt;v;
            add_line(u,v);
          }
          return 0;
      }

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法学习记录--快读，快速输出]]></title>
        <id>https://Spock12138.github.io/post/suan-fa-xue-xi-ji-lu-kuai-du-kuai-su-shu-chu/</id>
        <link href="https://Spock12138.github.io/post/suan-fa-xue-xi-ji-lu-kuai-du-kuai-su-shu-chu/">
        </link>
        <updated>2021-06-01T13:46:52.000Z</updated>
        <content type="html"><![CDATA[<p>对于数据量不大的题目，我们可以直接采用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">cin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cout</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span> 输入输出。当数据量相对大的时候，可以插入  ios::sync_with_stdio(false) 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">.</mi><mi>t</mi><mi>i</mi><mi>e</mi><mo>(</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">cin.tie(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord">.</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 关闭同步流。这时cin读入速度已经超过scanf了。<br>
但是遇到数据输入特别特别大(毒瘤)的情况下，以上方法均不适用。可以尝试使用快读</p>
<pre><code class="language-c++">inline int read()
{
    int c=0,f=1;
    char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){
        if(ch=='-')
        f*=-1;
        ch=getchar();
    }
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){
        c=c*10+ch-'0';//(c&lt;&lt;3)+(c&lt;&lt;1)
        ch=getchar();
    }
    return c*f;
}

</code></pre>
<p>快速输出(然而还没有printf()快)</p>
<pre><code class="language-c++">char f[200];
inline void write(int x)
{
   int tmp=x&gt;0?x:-x;
   if(x&lt;0)
   putchar('-');
   int cnt=0;
   while(tmp&gt;0){
       f[++cnt]=tmp%10+'0';
       tmp/=10;
   }
   while(cnt&gt;0){
       putchar(f[cnt]);
       --cnt;
   }
   return ;
}
</code></pre>
<p>递归模式的</p>
<pre><code class="language-c++">inline void write(int x)
{
    if(x&lt;0){
        putchar('-');
        x*=-1;
    }
    if(x&gt;9)
    write(x/10);
    putchar(x%10+'0');
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[会做字幕就可以为所欲为]]></title>
        <id>https://Spock12138.github.io/post/hui-zuo-zi-mu-jiu-ke-yi-wei-suo-yu-wei/</id>
        <link href="https://Spock12138.github.io/post/hui-zuo-zi-mu-jiu-ke-yi-wei-suo-yu-wei/">
        </link>
        <updated>2021-05-27T14:19:18.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p><strong>之前在摸鱼的时候，经常看到各种大神花式捕鲸。其中会做字幕的大佬带给了我特别多的欢乐，于是萌生了学习做字幕的想法。</strong></p>
<p>#所需要的工具<br>
aegisub--可以在网上直接下载，作用编辑字幕。<a href="https://www.bilibili.com/video/av6527949/">教程链接</a><br>
小丸子工具箱--用于格式转化。<a href="https://www.bilibili.com/video/av88335927/">下载链接</a></p>
<p>如果需要gif转化，gif剪切等操作，可以点<a href="https://ezgif.com/">这里</a></p>
<figure data-type="image" tabindex="1"><img src="https://Spock12138.github.io/post-images/1622125980466.gif" alt="" loading="lazy"></figure>
<p>更新，有个网站直接有模板，可以直接套用模板GIF，写出自己想要的台词。网站在<a href="https://sorry.xuty.tk/hataraku/">这里</a></p>
<figure data-type="image" tabindex="2"><img src="https://Spock12138.github.io/post-images/1622556335778.gif" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洛谷P1734最大约数和]]></title>
        <id>https://Spock12138.github.io/post/luo-gu-p1734-zui-da-yue-shu-he/</id>
        <link href="https://Spock12138.github.io/post/luo-gu-p1734-zui-da-yue-shu-he/">
        </link>
        <updated>2021-05-27T10:11:47.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>方法：找规律，加贪心背包。可以不用01背包</p>
<p>下表是举例的十个数。</p>
<table>
<thead>
<tr>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
</tr>
</tbody>
</table>
<p>可以看出， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>2</mn><mo>∗</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mn>2</mn><mo>∗</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[2*n+1]=f[2*n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>，由此我们的任务量缩减了一半。</p>
<p>第二步，分析上面的偶数，发现其最大约数和有两种情况，一是自己本身构成最大约数和，二是两个数相加构成最大约数和。如何判断是哪种情况呢，附上此部分关键代码</p>
<pre><code class="language-cpp">double d=ans*1.0/i;// 创建一个未知量记录约数与其本身比值
if(d&gt;maxn){        // 如果性价比高于这个比值进行替换操作
f[i]=ans;
flag=i;
maxn=d;
}
else {
f[i]=f[flag]+f[i-flag];// 否则装入之前最优比值 
}
</code></pre>
<p>第一篇题解，于五月十八日作</p>
<!-- more -->
]]></content>
    </entry>
</feed>